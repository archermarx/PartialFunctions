var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PartialFunctions\nDocTestSetup = quote\n    using PartialFunctions\nend","category":"page"},{"location":"#PartialFunctions","page":"Home","title":"PartialFunctions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a small Julia package that makes partial function application as simple as possible","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To apply an argument x to a function f, use the $ binary operator like so","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f $ x\nf(x, ...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To apply multiple arguments, wrap them in a Tuple, like you would a normal function call","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f $ (x, y, z)\nf(x, y, z, ...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f = println $ ((\"This is\", \"a Tuple\"),)\nprintln((\"This is\", \"a Tuple\"), ...)\n\njulia> f(\", and this is an additional argument\")\n(\"This is\", \"a Tuple\"), and this is an additional argument","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can add keyword arguments by passing a NamedTuple","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> sort_by_length = sort $ (;by = length)\nsort(...; by = length, ...)\n\njulia> sort_by_length([[1,2,3], [1,2]])\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 2, 3]","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can pass arguments and keyword arguments at the same time","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a = [[1,2,3], [1,2]];\n\njulia> sort_a_by_length = sort $ (a, (;by = length))\nsort([[1, 2, 3], [1, 2]], ...; by = length, ...)\n\njulia> sort_a_by_length()\n2-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 2, 3]","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also pass a tuple of arguments to this form, or pass the args first then the keyword args second to reduce the number of parentheses. Care must be taken here to avoid unintended results.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# These are equivalent\nsort $ a $ (;by = length)\nsort $ (a, (;by = length))\nsort $ ((a,), (;by = length))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following are incorrect, or will yield unintended results","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a = [[1,2,3], [1,2]];\n\njulia> sort $ (a, by = length)\nsort(..., a = [[1,2,3], [1,2]], by = length)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this first case, a is parsed as a part of the NamedTuple and is thus treated as a keyword argument instead of a positional argument","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> sort $ (a; by = length)\nsort(length, ... )","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the second case, the argument to julia $ is simply a block of two expressions, the result of which is the function length.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using PartialFunctions\n\njulia> a(x) = x^2\na (generic function with 1 method)\n\njulia> f = map $ a\nmap(a, ...)\n\njulia> f([1,2,3])\n3-element Vector{Int64}:\n 1\n 4\n 9","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> simonsays = println $ \"Simon says: \"\nprintln(\"Simon says: \", ...)\n\njulia> simonsays(\"Partial function application is cool!\")\nSimon says: Partial function application is cool!","category":"page"},{"location":"#Reversed-functions","page":"Home","title":"Reversed functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PartialFunctions exports the flip function, which creates a ReversedFunction object. This is a function which takes its arguments in reverse order.","category":"page"},{"location":"#The-Reverse-Pipe","page":"Home","title":"The Reverse Pipe","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PartialFunctions also exports the <|, or \"reverse pipe\" operator, which can be used to apply the arguments succeeding it to the function preceding it. This operator has low precedence, making it useful when chaining function calls if one wants to avoid a lot of parentheses","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here's an extremely contrived example to add a bunch of numbers together","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> (+) $ 2 $ 3 $ 5 $ 10 <| 12\n32","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unlike the normal pipe (|>), it can also be used with tuples of arguments","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> (+) <| (1, 2)...\n3","category":"page"},{"location":"","page":"Home","title":"Home","text":"Passing an empty tuple calls the preceding function with zero arguments","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> a = isequal $ (1, 2)\nisequal(1, 2, ...)\n\njulia> isequal $ (1, 2) <| ()   # equivalent to a() or isequal(1, 2)\nfalse","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = PartialFunctions","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [PartialFunctions]","category":"page"},{"location":"internals/#PartialFunctions.:$-Tuple{Function, Tuple}","page":"Internals","title":"PartialFunctions.:$","text":"($)(f::Function, args...)\n\nPartially apply the given arguments to f. Typically used as infix f $ args\n\nThe returned function is of type PartialFunctions.PartialFunction{typeof(f), typeof(args)}\n\nExamples\n\njulia> using PartialFunctions\n\njulia> simonsays = println $ \"Simon says: \"\nprintln(\"Simon says: \", ...)\n\njulia> simonsays(\"Partial function application is cool!\")\nSimon says: Partial function application is cool!\n\n\n\n\n\n","category":"method"},{"location":"internals/#PartialFunctions.:<|-Tuple{Function, Vararg{Any}}","page":"Internals","title":"PartialFunctions.:<|","text":"<|(f, args)\n\nApplies a function to the succeeding argument or tuple of arguments. Acts as the reverse of |>, and is especially useful when combined with partial functions for an alternative, low-parenthese function chaining syntax\n\nExamples\n\njulia> using PartialFunctions\n\njulia> isdigit <| '1'\ntrue\n\njulia> (+) <| (2, 3)...\n5\n\njulia> map $ Int <| [1.0, 2.0, 3.0]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"internals/#PartialFunctions.flip-Tuple{F} where F<:Function","page":"Internals","title":"PartialFunctions.flip","text":"flip(f::Function)\n\nCreates a function which takes arguments in backwards order from f, that is last argument first, and so on. Returns a PartialFunctions.ReversedFunction{typeof(f)}. Flipping a ReversedFunction returns the original function.\n\nExamples\n\njulia> firstsecond(first, second) = (first = first, second = second)\nfirstsecond (generic function with 1 method)\n\njulia> firstsecond(\"First thing\", \"Second thing\")\n(first = \"First thing\", second = \"Second thing\")\n\njulia> using PartialFunctions\n\njulia> secondfirst = flip(firstsecond);\n\njulia> secondfirst(\"First thing\", \"Second thing\")\n(first = \"Second thing\", second = \"First thing\")\n\n\n\n\n\n","category":"method"}]
}
